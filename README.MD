# ğŸ” Algoritmos de BÃºsqueda

## 1. Linear Search
- [x] ğŸ“Œ Recorres un arreglo elemento por elemento hasta encontrar lo que buscas.  
- [x] ğŸ› ï¸ `for`, `if`, comparaciÃ³n `===`.  
- [x] ğŸ¯ LÃ³gica secuencial, iteraciÃ³n.  
- [x] ğŸš€ Variante: buscar el Ã­ndice de todos los elementos que coincidan, no solo el primero.  

## 2. Binary Search
ğŸ“Œ Divide el arreglo a la mitad repetidamente para buscar un valor (requiere arreglo ordenado).  
ğŸ› ï¸ `while`, Ã­ndices `low` y `high`, matemÃ¡ticas (`Math.floor`).  
ğŸ¯ Pensar en divide y vencerÃ¡s.  
ğŸš€ Variante: hacerlo recursivo.  

---

# ğŸ”ƒ Algoritmos de Ordenamiento

## 3. Bubble Sort
ğŸ“Œ Compara pares de elementos y los intercambia hasta ordenar todo.  
ğŸ› ï¸ `for`, `if`, `swap` de valores.  
ğŸ¯ LÃ³gica de comparaciÃ³n, ciclos anidados.  
ğŸš€ Variante: detectar si ya estÃ¡ ordenado y terminar antes.  

## 4. Selection Sort
ğŸ“Œ Busca el mÃ­nimo en el arreglo y lo coloca al inicio, repite con el resto.  
ğŸ› ï¸ `for`, `if`, Ã­ndice auxiliar.  
ğŸ¯ Entender selecciÃ³n y reemplazo.  
ğŸš€ Variante: implementarlo descendente.  

## 5. Insertion Sort
ğŸ“Œ Inserta cada elemento en la posiciÃ³n correcta de una lista parcialmente ordenada.  
ğŸ› ï¸ `while`, comparaciÃ³n, `splice`.  
ğŸ¯ Pensar en mover elementos hacia atrÃ¡s.  
ğŸš€ Variante: optimizar con bÃºsqueda binaria.  

## 6. Merge Sort
ğŸ“Œ Divide el arreglo en mitades, ordena cada una y luego las combina.  
ğŸ› ï¸ RecursiÃ³n, arrays, `slice`.  
ğŸ¯ Divide y vencerÃ¡s.  
ğŸš€ Variante: hacerlo iterativo con bucles.  

## 7. Quick Sort
ğŸ“Œ Elige un pivote y divide en menores/mayores al pivote, luego ordena recursivamente.  
ğŸ› ï¸ RecursiÃ³n, arrays (`filter` o bucles).  
ğŸ¯ Manejar particiones.  
ğŸš€ Variante: probar distintos mÃ©todos para elegir pivote.  

---

# ğŸ” Algoritmos de RecursiÃ³n

## 8. Serie Fibonacci
ğŸ“Œ Cada nÃºmero es suma de los dos anteriores.  
ğŸ› ï¸ RecursiÃ³n, condicionales.  
ğŸ¯ Pensar en casos base.  
ğŸš€ Variante: optimizar con memoization.  

## 9. Factorial
ğŸ“Œ Producto de todos los nÃºmeros desde `n` hasta `1`.  
ğŸ› ï¸ RecursiÃ³n o bucles.  
ğŸ¯ Casos base y decrecimiento.  
ğŸš€ Variante: manejar nÃºmeros grandes con BigInt.  

## 10. Torre de Hanoi
ğŸ“Œ Mover discos de una torre a otra sin violar reglas.  
ğŸ› ï¸ RecursiÃ³n, impresiÃ³n de pasos.  
ğŸ¯ PlanificaciÃ³n de movimientos.  
ğŸš€ Variante: calcular nÃºmero mÃ­nimo de movimientos.  

## 11. Suma de N nÃºmeros naturales
ğŸ“Œ Sumar de `1` a `n`.  
ğŸ› ï¸ RecursiÃ³n o fÃ³rmula matemÃ¡tica.  
ğŸ¯ Pensar en reducciÃ³n de problema.  
ğŸš€ Variante: hacerlo con programaciÃ³n funcional (`reduce`).  

---

# ğŸ”¤ Algoritmos para Cadenas

## 12. Reverse string (sin `.reverse()`)
ğŸ“Œ Invertir caracteres de un string.  
ğŸ› ï¸ Bucles, arrays, concatenaciÃ³n.  
ğŸ¯ Pensar en Ã­ndices.  
ğŸš€ Variante: hacerlo recursivo.  

## 13. PalÃ­ndromo
ğŸ“Œ Revisar si una palabra se lee igual al derecho y al revÃ©s.  
ğŸ› ï¸ Strings, bucles, `toLowerCase()`.  
ğŸ¯ Comparaciones.  
ğŸš€ Variante: ignorar espacios y signos.  

## 14. Contar caracteres
ğŸ“Œ Calcular cuÃ¡ntas veces aparece cada letra.  
ğŸ› ï¸ Objetos como diccionario, bucles.  
ğŸ¯ Mapear frecuencias.  
ğŸš€ Variante: hacerlo con `Map`.  

## 15. Buscar subcadenas
ğŸ“Œ Verificar si un substring existe dentro de otro string.  
ğŸ› ï¸ `includes()`, bucles, slicing.  
ğŸ¯ Manejar rangos de Ã­ndices.  
ğŸš€ Variante: implementar algoritmo KMP o Boyer-Moore (avanzado).  

## 16. Anagramas
ğŸ“Œ Revisar si dos palabras tienen las mismas letras en diferente orden.  
ğŸ› ï¸ Ordenar letras, objetos de conteo.  
ğŸ¯ Comparar estructuras.  
ğŸš€ Variante: verificar lista completa de palabras.  

---

# ğŸ”¢ Algoritmos de MatemÃ¡ticas

## 17. NÃºmeros primos
ğŸ“Œ Verificar si un nÃºmero solo es divisible por 1 y Ã©l mismo.  
ğŸ› ï¸ MÃ³dulo `%`, bucles.  
ğŸ¯ OptimizaciÃ³n en divisores.  
ğŸš€ Variante: generar lista de primos (Criba de EratÃ³stenes).  

## 18. ExponenciaciÃ³n rÃ¡pida
ğŸ“Œ Calcular potencias con dividir y vencerÃ¡s (`n^k`).  
ğŸ› ï¸ RecursiÃ³n, multiplicaciÃ³n.  
ğŸ¯ Pensar en casos pares/impares.  
ğŸš€ Variante: modular exponentiation.  

## 19. Suma y multiplicaciÃ³n de matrices 2x2
ğŸ“Œ Operaciones bÃ¡sicas de Ã¡lgebra lineal.  
ğŸ› ï¸ Arrays bidimensionales.  
ğŸ¯ IndexaciÃ³n de matrices.  
ğŸš€ Variante: generalizar a NxN.  

## 20. Conteo con HashMap
ğŸ“Œ Contar frecuencia de palabras o duplicados en un arreglo.  
ğŸ› ï¸ Objetos `{}`, `Map`.  
ğŸ¯ AgrupaciÃ³n y conteo.  
ğŸš€ Variante: hacerlo sensible a mayÃºsculas/minÃºsculas.  

---

# ğŸ—ºï¸ Algoritmos de Recorrido de Matrices

## 21. BÃºsqueda en matrices
ğŸ“Œ Buscar un valor en una matriz (lineal o binaria por fila/columna).  
ğŸ› ï¸ Bucles anidados.  
ğŸ¯ Pensar en coordenadas.  
ğŸš€ Variante: matriz ordenada â†’ bÃºsqueda optimizada.  

## 22. Caminos en espiral
ğŸ“Œ Imprimir elementos de matriz en forma de espiral.  
ğŸ› ï¸ Bucles, lÃ­mites dinÃ¡micos.  
ğŸ¯ Control de bordes.  
ğŸš€ Variante: hacerlo recursivo.  

## 23. BFS (Breadth First Search)
ğŸ“Œ Recorrer nodos nivel por nivel.  
ğŸ› ï¸ Colas (`shift`, `push`).  
ğŸ¯ Manejar grafos o grids.  
ğŸš€ Variante: shortest path en un grafo.  

## 24. DFS (Depth First Search)
ğŸ“Œ Recorrer nodos en profundidad antes de retroceder.  
ğŸ› ï¸ Pila (`push`, `pop`) o recursiÃ³n.  
ğŸ¯ Backtracking.  
ğŸš€ Variante: resolver laberintos.  
